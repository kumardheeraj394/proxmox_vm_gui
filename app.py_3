from flask import Flask, render_template, request, jsonify, redirect, url_for, session, flash
import os, json, time, socket, threading, subprocess, sqlite3
from functools import wraps
from werkzeug.security import generate_password_hash, check_password_hash

# ---------------- APP ----------------
app = Flask(__name__)
app.secret_key = "supersecretkey"

DB_PATH = "proxmox_gui.db"
LOGS_DIR = "/tmp/proxmox_logs"
DISCOVER_JSON = "/tmp/proxmox_discover.json"
PLAYBOOK_PATH = "proxmox_vm/tests/test.yml"
INVENTORY_PATH = "proxmox_vm/tests/inventory"

os.makedirs(LOGS_DIR, exist_ok=True)

# ---------------- DB INIT ----------------
def init_db():
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()

    # users table
    c.execute("""
        CREATE TABLE IF NOT EXISTS users (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            username TEXT UNIQUE,
            email TEXT,
            password TEXT,
            role TEXT DEFAULT 'user'
        )
    """)

    # vm status table (1 row per VMID only)
    c.execute("""
        CREATE TABLE IF NOT EXISTS vm_status (
            vmid TEXT PRIMARY KEY,
            vmname TEXT,
            ipaddr TEXT,
            target_node TEXT,
            ssh_port INTEGER,
            ssh_status TEXT,
            timestamp INTEGER,
            created_by TEXT
        )
    """)

    conn.commit()
    conn.close()

init_db()

# ---------------- HELPERS ----------------
def ssh_up(ipaddr, port, timeout=2):
    try:
        host = ipaddr.split("/")[0]
        with socket.create_connection((host, int(port)), timeout):
            return True
    except:
        return False

def login_required(f):
    @wraps(f)
    def wrap(*args, **kwargs):
        if "username" not in session:
            flash("Login required", "warning")
            return redirect(url_for("login"))
        return f(*args, **kwargs)
    return wrap

def admin_required(f):
    @wraps(f)
    def wrap(*args, **kwargs):
        if session.get("role") != "admin":
            flash("Admin only", "danger")
            return redirect(url_for("dashboard"))
        return f(*args, **kwargs)
    return wrap

# ---------------- AUTH ----------------
@app.route("/login", methods=["GET", "POST"])
def login():
    if request.method == "POST":
        u = request.form["username"]
        p = request.form["password"]

        conn = sqlite3.connect(DB_PATH)
        c = conn.cursor()
        c.execute("SELECT password, role FROM users WHERE username=?", (u,))
        row = c.fetchone()
        conn.close()

        if row and check_password_hash(row[0], p):
            session["username"] = u
            session["role"] = row[1]
            return redirect(url_for("dashboard"))

        flash("Invalid login", "danger")

    return render_template("login.html")

@app.route("/logout")
def logout():
    session.clear()
    return redirect(url_for("login"))

# ---------------- DASHBOARD ----------------
@app.route("/dashboard")
@login_required
def dashboard():
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()

    c.execute("""
        SELECT vmid, vmname, ipaddr, target_node, ssh_port,
               ssh_status, timestamp, created_by
        FROM vm_status
        ORDER BY timestamp DESC
    """)
    rows = c.fetchall()

    users = []
    if session["role"] == "admin":
        c.execute("SELECT username, email, role FROM users")
        users = c.fetchall()

    conn.close()

    vms = []
    for r in rows:
        vms.append({
            "vmid": r[0],
            "vmname": r[1],
            "ipaddr": r[2],
            "target_node": r[3],
            "ssh_port": r[4],
            "ssh_status": r[5],
            "timestamp": time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(r[6])),
            "created_by": r[7]
        })

    return render_template(
        "dashboard.html",
        vms=vms,
        users=users,
        username=session["username"],
        role=session["role"]
    )

# ---------------- VM FORM (FIXED) ----------------
@app.route("/vm_form")
@login_required
def vm_form():
    data = {"nodes": [], "storage": [], "images": []}

    if os.path.exists(DISCOVER_JSON):
        with open(DISCOVER_JSON) as f:
            data = json.load(f)

    return render_template(
        "form.html",
        nodes=data.get("nodes", []),
        storage=data.get("storage", []),
        images=data.get("images", []),
        ssh_port=10457
    )

# ---------------- RUN PLAYBOOK ----------------
@app.route("/run", methods=["POST"])
@login_required
def run():
    payload = request.json
    ts = int(time.time())

    vars_file = f"{LOGS_DIR}/run_{ts}.json"
    with open(vars_file, "w") as f:
        json.dump(payload, f)

    ssh_port = int(payload.get("ssh_port", 10457))
    user = session["username"]

    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()

    # single VM
    if payload.get("vmid"):
        c.execute("""
            INSERT OR REPLACE INTO vm_status
            (vmid, vmname, ipaddr, target_node, ssh_port,
             ssh_status, timestamp, created_by)
            VALUES (?,?,?,?,?,?,?,?)
        """, (
            payload["vmid"],
            payload["vmname"],
            payload["ipaddr"],
            payload["target_node"],
            ssh_port,
            "CHECKING",
            ts,
            user
        ))

    # clones
    for cl in payload.get("clones", []):
        c.execute("""
            INSERT OR REPLACE INTO vm_status
            (vmid, vmname, ipaddr, target_node, ssh_port,
             ssh_status, timestamp, created_by)
            VALUES (?,?,?,?,?,?,?,?)
        """, (
            cl["clonevmid"],
            cl["clonevmname"],
            cl["cloneipaddr"],
            cl["clonetarget_node"],
            ssh_port,
            "CHECKING",
            ts,
            user
        ))

    conn.commit()
    conn.close()

    threading.Thread(target=run_playbook, args=(vars_file,), daemon=True).start()
    return jsonify({"status": "started"})

def run_playbook(vars_file):
    subprocess.Popen([
        "ansible-playbook",
        PLAYBOOK_PATH,
        "-i", INVENTORY_PATH,
        "--extra-vars", f"@{vars_file}"
    ])

# ---------------- SSH STATUS ----------------
@app.route("/status")
@login_required
def status():
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()

    c.execute("SELECT vmid, ipaddr, ssh_port FROM vm_status")
    rows = c.fetchall()
    now = int(time.time())

    for vmid, ip, port in rows:
        state = "ONLINE" if ssh_up(ip, port) else "OFFLINE"
        c.execute("""
            UPDATE vm_status
            SET ssh_status=?, timestamp=?
            WHERE vmid=?
        """, (state, now, vmid))

    conn.commit()
    conn.close()
    return jsonify({"updated": True})

# ---------------- USER MANAGEMENT ----------------
@app.route("/create_user", methods=["GET", "POST"])
@login_required
@admin_required
def create_user():
    if request.method == "POST":
        username = request.form["username"]
        password = request.form["password"]
        email = request.form.get("email", "")
        role = request.form.get("role", "user")

        hashed = generate_password_hash(password)

        try:
            conn = sqlite3.connect(DB_PATH)
            c = conn.cursor()
            c.execute("""
                INSERT INTO users (username,email,password,role)
                VALUES (?,?,?,?)
            """, (username, email, hashed, role))
            conn.commit()
            conn.close()
            flash("User created", "success")
            return redirect(url_for("dashboard"))
        except sqlite3.IntegrityError:
            flash("Username already exists", "danger")

    return render_template("create_user.html")

@app.route("/modify_user/<username>", methods=["GET", "POST"])
@login_required
@admin_required
def modify_user(username):
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()

    if request.method == "POST":
        email = request.form.get("email")
        role = request.form.get("role")
        password = request.form.get("password")

        if password:
            hashed = generate_password_hash(password)
            c.execute("""
                UPDATE users SET email=?, role=?, password=?
                WHERE username=?
            """, (email, role, hashed, username))
        else:
            c.execute("""
                UPDATE users SET email=?, role=?
                WHERE username=?
            """, (email, role, username))

        conn.commit()
        conn.close()
        flash("User updated", "success")
        return redirect(url_for("dashboard"))

    c.execute("SELECT username, email, role FROM users WHERE username=?", (username,))
    user = c.fetchone()
    conn.close()

    return render_template("modify_user.html", user=user)

# ---------------- DELETE VM ----------------
@app.route("/delete_vm/<vmid>")
@login_required
@admin_required
def delete_vm(vmid):
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute("DELETE FROM vm_status WHERE vmid=?", (vmid,))
    conn.commit()
    conn.close()
    flash("VM deleted", "success")
    return redirect(url_for("dashboard"))

# ---------------- MAIN ----------------
if __name__ == "__main__":
    app.run(host="0.0.0.0", port=8000, debug=True)

